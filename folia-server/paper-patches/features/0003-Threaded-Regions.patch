From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Sun, 2 Oct 2022 21:28:53 -0700
Subject: [PATCH] Threaded Regions

See https://docs.papermc.io/folia/reference/overview and
https://docs.papermc.io/folia/reference/region-logic

diff --git a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
index 157e5edb507d6d2a922833c70a1c27abc93c9c34..5aa2891d52fb246329bf3483059b069b86fd621a 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
@@ -1,5 +1,11 @@
 package ca.spottedleaf.moonrise.common.util;
 
+import io.papermc.paper.threadedregions.RegionShutdownThread;
+import io.papermc.paper.threadedregions.RegionizedServer;
+import io.papermc.paper.threadedregions.RegionizedWorldData;
+import io.papermc.paper.threadedregions.ThreadedRegionizer;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
+import io.papermc.paper.threadedregions.TickRegions;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.ChunkPos;
@@ -119,50 +125,157 @@ public class TickThread extends Thread {
     }
 
     public static boolean isShutdownThread() {
-        return false;
+        return Thread.currentThread().getClass() == RegionShutdownThread.class;
     }
 
     public static boolean isTickThreadFor(final Level world, final BlockPos pos) {
-        return isTickThread();
+        return isTickThreadFor(world, pos.getX() >> 4, pos.getZ() >> 4);
     }
 
     public static boolean isTickThreadFor(final Level world, final BlockPos pos, final int blockRadius) {
-        return isTickThread();
+        return isTickThreadFor(
+                world,
+                (pos.getX() - blockRadius) >> 4, (pos.getZ() - blockRadius) >> 4,
+                (pos.getX() + blockRadius) >> 4, (pos.getZ() + blockRadius) >> 4
+        );
     }
 
     public static boolean isTickThreadFor(final Level world, final ChunkPos pos) {
-        return isTickThread();
+        return isTickThreadFor(world, pos.x, pos.z);
     }
 
     public static boolean isTickThreadFor(final Level world, final Vec3 pos) {
-        return isTickThread();
+        return isTickThreadFor(world, net.minecraft.util.Mth.floor(pos.x) >> 4, net.minecraft.util.Mth.floor(pos.z) >> 4);
     }
 
     public static boolean isTickThreadFor(final Level world, final int chunkX, final int chunkZ) {
-        return isTickThread();
+        final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+            TickRegionScheduler.getCurrentRegion();
+        if (region == null) {
+            return isShutdownThread();
+        }
+        return ((net.minecraft.server.level.ServerLevel)world).regioniser.getRegionAtUnsynchronised(chunkX, chunkZ) == region;
     }
 
     public static boolean isTickThreadFor(final Level world, final AABB aabb) {
-        return isTickThread();
+        return isTickThreadFor(
+            world,
+            CoordinateUtils.getChunkCoordinate(aabb.minX), CoordinateUtils.getChunkCoordinate(aabb.minZ),
+            CoordinateUtils.getChunkCoordinate(aabb.maxX), CoordinateUtils.getChunkCoordinate(aabb.maxZ)
+        );
     }
 
     public static boolean isTickThreadFor(final Level world, final double blockX, final double blockZ) {
-        return isTickThread();
+        return isTickThreadFor(world, CoordinateUtils.getChunkCoordinate(blockX), CoordinateUtils.getChunkCoordinate(blockZ));
     }
 
     public static boolean isTickThreadFor(final Level world, final Vec3 position, final Vec3 deltaMovement, final int buffer) {
-        return isTickThread();
+        final int fromChunkX = CoordinateUtils.getChunkX(position);
+        final int fromChunkZ = CoordinateUtils.getChunkZ(position);
+
+        final int toChunkX = CoordinateUtils.getChunkCoordinate(position.x + deltaMovement.x);
+        final int toChunkZ = CoordinateUtils.getChunkCoordinate(position.z + deltaMovement.z);
+
+        // expect from < to, but that may not be the case
+        return isTickThreadFor(
+            world,
+            Math.min(fromChunkX, toChunkX) - buffer,
+            Math.min(fromChunkZ, toChunkZ) - buffer,
+            Math.max(fromChunkX, toChunkX) + buffer,
+            Math.max(fromChunkZ, toChunkZ) + buffer
+        );
     }
 
     public static boolean isTickThreadFor(final Level world, final int fromChunkX, final int fromChunkZ, final int toChunkX, final int toChunkZ) {
-        return isTickThread();
+        final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+            TickRegionScheduler.getCurrentRegion();
+        if (region == null) {
+            return isShutdownThread();
+        }
+
+        final int shift = ((net.minecraft.server.level.ServerLevel)world).regioniser.sectionChunkShift;
+
+        final int minSectionX = fromChunkX >> shift;
+        final int maxSectionX = toChunkX >> shift;
+        final int minSectionZ = fromChunkZ >> shift;
+        final int maxSectionZ = toChunkZ >> shift;
+
+        for (int secZ = minSectionZ; secZ <= maxSectionZ; ++secZ) {
+            for (int secX = minSectionX; secX <= maxSectionX; ++secX) {
+                final int lowerLeftCX = secX << shift;
+                final int lowerLeftCZ = secZ << shift;
+                if (((net.minecraft.server.level.ServerLevel)world).regioniser.getRegionAtUnsynchronised(lowerLeftCX, lowerLeftCZ) != region) {
+                    return false;
+                }
+            }
+        }
+
+        return true;
     }
 
     public static boolean isTickThreadFor(final Level world, final int chunkX, final int chunkZ, final int radius) {
-        return isTickThread();
+        return isTickThreadFor(world, chunkX - radius, chunkZ - radius, chunkX + radius, chunkZ + radius);
     }
 
     public static boolean isTickThreadFor(final Entity entity) {
-        return isTickThread();
+        if (entity == null) {
+            return true;
+        }
+        final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+            TickRegionScheduler.getCurrentRegion();
+        if (region == null) {
+            if (RegionizedServer.isGlobalTickThread()) {
+                if (entity instanceof net.minecraft.server.level.ServerPlayer serverPlayer) {
+                    final net.minecraft.server.network.ServerGamePacketListenerImpl possibleBad = serverPlayer.connection;
+                    if (possibleBad == null) {
+                        return true;
+                    }
+
+                    final net.minecraft.network.PacketListener packetListener = possibleBad.connection.getPacketListener();
+                    if (packetListener instanceof net.minecraft.server.network.ServerGamePacketListenerImpl gamePacketListener) {
+                        return gamePacketListener.waitingForSwitchToConfig;
+                    }
+                    if (packetListener instanceof net.minecraft.server.network.ServerConfigurationPacketListenerImpl configurationPacketListener) {
+                        return !configurationPacketListener.switchToMain;
+                    }
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+            if (isShutdownThread()) {
+                return true;
+            }
+            if (entity instanceof net.minecraft.server.level.ServerPlayer serverPlayer) {
+                // off-main access to server player is never ok, server player is owned by one of global context or region context always
+                return false;
+            }
+            // only own entities that have not yet been added to the world
+
+            // if the entity is removed, then it was in the world previously - which means that a region containing its location
+            // owns it
+            // if the entity has a callback, then it is contained in a world
+            return entity.hasNullCallback() && !entity.isRemoved();
+        }
+
+        final Level world = entity.level();
+        if (world != region.regioniser.world) {
+            // world mismatch
+            return false;
+        }
+
+        final RegionizedWorldData worldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData();
+
+        // pass through the check if the entity is removed and we own its chunk
+        if (worldData.hasEntity(entity)) {
+            return true;
+        }
+        
+        if (entity instanceof net.minecraft.server.level.ServerPlayer serverPlayer) {
+            net.minecraft.server.network.ServerGamePacketListenerImpl conn = serverPlayer.connection;
+            return conn != null && worldData.connections.contains(conn.connection);
+        } else {
+            return ((entity.hasNullCallback() || entity.isRemoved())) && isTickThreadFor((net.minecraft.server.level.ServerLevel)world, entity.chunkPosition());
+        }
     }
 }
diff --git a/src/main/java/io/papermc/paper/SparksFly.java b/src/main/java/io/papermc/paper/SparksFly.java
index 62e2d5704c348955bc8284dc2d54c933b7bcdd06..2ad5b9b0b7e18780ee73310451d9fa73f44c4bdb 100644
--- a/src/main/java/io/papermc/paper/SparksFly.java
+++ b/src/main/java/io/papermc/paper/SparksFly.java
@@ -33,13 +33,13 @@ public final class SparksFly {
 
     private final Logger logger;
     private final PaperSparkModule spark;
-    private final ConcurrentLinkedQueue<Runnable> mainThreadTaskQueue;
+    // Folia - region threading
 
     private boolean enabled;
     private boolean disabledInConfigurationWarningLogged;
 
     public SparksFly(final Server server) {
-        this.mainThreadTaskQueue = new ConcurrentLinkedQueue<>();
+        // Folia - region threading
         this.logger = Logger.getLogger(ID);
         this.logger.log(Level.INFO, "This server bundles the spark profiler. For more information please visit https://docs.papermc.io/paper/profiling");
         this.spark = PaperSparkModule.create(Compatibility.VERSION_1_0, server, this.logger, new PaperScheduler() {
@@ -50,7 +50,7 @@ public final class SparksFly {
 
             @Override
             public void executeSync(final Runnable runnable) {
-                SparksFly.this.mainThreadTaskQueue.offer(this.catching(runnable, "synchronous"));
+                io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(this.catching(runnable, "synchronous")); // Folia - region threading
             }
 
             private Runnable catching(final Runnable runnable, final String type) {
@@ -88,10 +88,7 @@ public final class SparksFly {
     }
 
     public void executeMainThreadTasks() {
-        Runnable task;
-        while ((task = this.mainThreadTaskQueue.poll()) != null) {
-            task.run();
-        }
+        throw new UnsupportedOperationException(); // Folia - region threading
     }
 
     public void enableEarlyIfRequested() {
diff --git a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
index 14e412ebf75b0e06ab53a1c8f9dd1be6ad1e2680..3f733319482fedcf7461f4b7466e84afeae1fc2b 100644
--- a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
+++ b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
@@ -83,7 +83,7 @@ public final class ChatProcessor {
             final CraftPlayer player = this.player.getBukkitEntity();
             final AsyncPlayerChatEvent ae = new AsyncPlayerChatEvent(this.async, player, this.craftbukkit$originalMessage, new LazyPlayerSet(this.server));
             this.post(ae);
-            if (listenersOnSyncEvent) {
+            if (false && listenersOnSyncEvent) { // Folia - region threading
                 final PlayerChatEvent se = new PlayerChatEvent(player, ae.getMessage(), ae.getFormat(), ae.getRecipients());
                 se.setCancelled(ae.isCancelled()); // propagate cancelled state
                 this.queueIfAsyncOrRunImmediately(new Waitable<Void>() {
@@ -150,7 +150,7 @@ public final class ChatProcessor {
         ae.setCancelled(cancelled); // propagate cancelled state
         this.post(ae);
         final boolean listenersOnSyncEvent = canYouHearMe(ChatEvent.getHandlerList());
-        if (listenersOnSyncEvent) {
+        if (false && listenersOnSyncEvent) { // Folia - region threading
             this.queueIfAsyncOrRunImmediately(new Waitable<Void>() {
                 @Override
                 protected Void evaluate() {
diff --git a/src/main/java/io/papermc/paper/adventure/providers/ClickCallbackProviderImpl.java b/src/main/java/io/papermc/paper/adventure/providers/ClickCallbackProviderImpl.java
index 23432eea862c6df716d7726a32da3a0612a3fb77..f59e8bb72c5233f26a8a0d506ac64bb37fef97a5 100644
--- a/src/main/java/io/papermc/paper/adventure/providers/ClickCallbackProviderImpl.java
+++ b/src/main/java/io/papermc/paper/adventure/providers/ClickCallbackProviderImpl.java
@@ -23,35 +23,42 @@ public class ClickCallbackProviderImpl implements ClickCallback.Provider {
 
     public static final class CallbackManager {
 
-        private final Map<UUID, StoredCallback> callbacks = new HashMap<>();
-        private final Queue<StoredCallback> queue = new ConcurrentLinkedQueue<>();
+        private final java.util.concurrent.ConcurrentHashMap<UUID, StoredCallback> callbacks = new java.util.concurrent.ConcurrentHashMap<>(); // Folia - region threading
+        // Folia - region threading
 
         private CallbackManager() {
         }
 
         public UUID addCallback(final @NotNull ClickCallback<Audience> callback, final ClickCallback.@NotNull Options options) {
             final UUID id = UUID.randomUUID();
-            this.queue.add(new StoredCallback(callback, options, id));
+            final StoredCallback scb = new StoredCallback(callback, options, id); // Folia - region threading
+            this.callbacks.put(scb.id(), scb); // Folia - region threading
             return id;
         }
 
         public void handleQueue(final int currentTick) {
             // Evict expired entries
             if (currentTick % 100 == 0) {
-                this.callbacks.values().removeIf(callback -> !callback.valid());
+                this.callbacks.values().removeIf(StoredCallback::expired); // Folia - region threading - don't read uses field
             }
 
-            // Add entries from queue
-            StoredCallback callback;
-            while ((callback = this.queue.poll()) != null) {
-                this.callbacks.put(callback.id(), callback);
-            }
+            // Folia - region threading
         }
 
         public void runCallback(final @NotNull Audience audience, final UUID id) {
-            final StoredCallback callback = this.callbacks.get(id);
-            if (callback != null && callback.valid()) { //TODO Message if expired/invalid?
-                callback.takeUse();
+            // Folia start - region threading
+            final StoredCallback[] use = new StoredCallback[1];
+            this.callbacks.computeIfPresent(id, (final UUID keyInMap, final StoredCallback value) -> {
+                if (!value.valid()) {
+                    return null;
+                }
+                use[0] = value;
+                value.takeUse();
+                return value.valid() ? value : null;
+            });
+            final StoredCallback callback = use[0];
+            if (callback != null) { //TODO Message if expired/invalid?
+                // Folia end - region threading
                 callback.callback.accept(audience);
             }
         }
diff --git a/src/main/java/io/papermc/paper/command/PaperCommands.java b/src/main/java/io/papermc/paper/command/PaperCommands.java
index 7b58b2d6297800c2dcdbf7539e5ab8e7703f39f1..a587d83b78af4efc484f939529acf70834f60d7e 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommands.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommands.java
@@ -19,6 +19,7 @@ public final class PaperCommands {
         COMMANDS.put("paper", new PaperCommand("paper"));
         COMMANDS.put("callback", new CallbackCommand("callback"));
         COMMANDS.put("mspt", new MSPTCommand("mspt"));
+        COMMANDS.put("tps", new io.papermc.paper.threadedregions.commands.CommandServerHealth()); // Folia - region threading
     }
 
     public static void registerCommands(final MinecraftServer server) {
diff --git a/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java b/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java
index bbd29bcca94a81ad2603afa9ddcb160e925b405e..6284384299000480e9d5c0b62e8d88b2c922e776 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/EntityCommand.java
@@ -129,7 +129,7 @@ public final class EntityCommand implements PaperSubcommand {
                         final int z = (e.getKey().z << 4) + 8;
                         final Component message = text("  " + e.getValue() + ": " + e.getKey().x + ", " + e.getKey().z + (chunkProviderServer.isPositionTicking(e.getKey().toLong()) ? " (Ticking)" : " (Non-Ticking)"))
                             .hoverEvent(HoverEvent.showText(text("Click to teleport to chunk", GREEN)))
-                            .clickEvent(ClickEvent.clickEvent(ClickEvent.Action.RUN_COMMAND, "/minecraft:execute as @s in " + world.getWorld().getKey() + " run tp " + x + " " + (world.getWorld().getHighestBlockYAt(x, z, HeightMap.MOTION_BLOCKING) + 1) + " " + z));
+                            .clickEvent(ClickEvent.clickEvent(ClickEvent.Action.RUN_COMMAND, "/minecraft:execute as @s in " + world.getWorld().getKey() + " run tp " + x + " " + (128) + " " + z)); // Folia - region threading - avoid sync load here
                         sender.sendMessage(message);
                     });
             } else {
diff --git a/src/main/java/io/papermc/paper/command/subcommands/HeapDumpCommand.java b/src/main/java/io/papermc/paper/command/subcommands/HeapDumpCommand.java
index cd2e4d792e972b8bf1e07b8961594a670ae949cf..3ab8dbf2768a4ef8fb53af6f5431f7f6afe6d168 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/HeapDumpCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/HeapDumpCommand.java
@@ -18,7 +18,9 @@ import static net.kyori.adventure.text.format.NamedTextColor.YELLOW;
 public final class HeapDumpCommand implements PaperSubcommand {
     @Override
     public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> { // Folia - region threading
         this.dumpHeap(sender);
+        }); // Folia - region threading
         return true;
     }
 
diff --git a/src/main/java/io/papermc/paper/command/subcommands/ReloadCommand.java b/src/main/java/io/papermc/paper/command/subcommands/ReloadCommand.java
index bd68139ae635f2ad7ec8e7a21e0056a139c4c62e..48a43341b17247355a531164019d5cc9c5555f26 100644
--- a/src/main/java/io/papermc/paper/command/subcommands/ReloadCommand.java
+++ b/src/main/java/io/papermc/paper/command/subcommands/ReloadCommand.java
@@ -16,7 +16,9 @@ import static net.kyori.adventure.text.format.NamedTextColor.RED;
 public final class ReloadCommand implements PaperSubcommand {
     @Override
     public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> { // Folia - region threading
         this.doReload(sender);
+        }); // Folia - region threading
         return true;
     }
 
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 0b8e0ff5ce628cd1023de45ab0bff112f74dc695..c6805510805c91e301da2363b7011f93174bc7f0 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -396,4 +396,17 @@ public class GlobalConfiguration extends ConfigurationPart {
             }
         }
     }
+    // Folia start - threaded regions
+    public ThreadedRegions threadedRegions;
+    public class ThreadedRegions extends ConfigurationPart {
+
+        public int threads = -1;
+        public int gridExponent = 4;
+
+        @PostProcess
+        public void postProcess() {
+            io.papermc.paper.threadedregions.TickRegions.init(this);
+        }
+    }
+    // Folia end - threaded regions
 }
diff --git a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
index d7c9acaffdcff5e35e026ae90a3e521bab13b074..321c4cad4f84c57f56e5bec3bcdbbef8823f70fe 100644
--- a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
@@ -493,6 +493,14 @@ public class WorldConfiguration extends ConfigurationPart {
     public Chunks chunks;
 
     public class Chunks extends ConfigurationPart {
+
+        // Folia start - region threading - force prevent moving into unloaded chunks
+        @PostProcess
+        public void postProcess() {
+            this.preventMovingIntoUnloadedChunks = true;
+        }
+        // Folia end - region threading - force prevent moving into unloaded chunks
+
         public AutosavePeriod autoSaveInterval = AutosavePeriod.def();
         public int maxAutoSaveChunksPerTick = 24;
         public int fixedChunkInhabitedTime = -1;
diff --git a/src/main/java/io/papermc/paper/entity/activation/ActivationType.java b/src/main/java/io/papermc/paper/entity/activation/ActivationType.java
index cd43845a0819b5b63259d7a87ebb1cf5659ea5bc..01fef8353934f22a5176e731847d3df4a7df5306 100644
--- a/src/main/java/io/papermc/paper/entity/activation/ActivationType.java
+++ b/src/main/java/io/papermc/paper/entity/activation/ActivationType.java
@@ -19,7 +19,7 @@ public enum ActivationType {
     RAIDER,
     MISC;
 
-    AABB boundingBox = new AABB(0, 0, 0, 0, 0, 0);
+    //AABB boundingBox = new AABB(0, 0, 0, 0, 0, 0); // Folia - threaded regions - replaced by local variable
 
     /**
      * Returns the activation type for the given entity.
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
index 3e82ea07ca4194844c5528446e2c4a46ff4acee5..adfd4c16809f6ddd9cc73e4bd845d7aed4925068 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperPluginInstanceManager.java
@@ -256,12 +256,7 @@ class PaperPluginInstanceManager {
                 + pluginName + " (Is it up to date?)", ex, plugin); // Paper
         }
 
-        try {
-            this.server.getScheduler().cancelTasks(plugin);
-        } catch (Throwable ex) {
-            this.handlePluginException("Error occurred (in the plugin loader) while cancelling tasks for "
-                + pluginName + " (Is it up to date?)", ex, plugin); // Paper
-        }
+        // Folia - region threading
 
         // Paper start - Folia schedulers
         try {
diff --git a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
index c03608fec96b51e1867f43d8f42e5aefb1520e46..127d96280cad2d4e5db574a089d67ad68977b34e 100644
--- a/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/EntityScheduler.java
@@ -50,6 +50,14 @@ public final class EntityScheduler {
         this.entity = Validate.notNull(entity);
     }
 
+    // Folia start - region threading
+    public boolean isRetired() {
+        synchronized (this.stateLock) {
+            return this.tickCount == RETIRED_TICK_COUNT;
+        }
+    }
+    // Folia end - region threading
+
     /**
      * Retires the scheduler, preventing new tasks from being scheduled and invoking the retired callback
      * on all currently scheduled tasks.
diff --git a/src/main/java/io/papermc/paper/util/MCUtil.java b/src/main/java/io/papermc/paper/util/MCUtil.java
index a4ac34ebb58a404f4fca7e763e61d4ab05ee3af4..4dcec640f5870d713bd3b98389a45dbef8a4ea8a 100644
--- a/src/main/java/io/papermc/paper/util/MCUtil.java
+++ b/src/main/java/io/papermc/paper/util/MCUtil.java
@@ -94,6 +94,7 @@ public final class MCUtil {
      */
     public static void ensureMain(String reason, Runnable run) {
         if (!isMainThread()) {
+            if (true) throw new UnsupportedOperationException(); // Folia - region threading
             if (reason != null) {
                 MinecraftServer.LOGGER.warn("Asynchronous " + reason + "!", new IllegalStateException());
             }
@@ -148,6 +149,30 @@ public final class MCUtil {
         return new Location(world.getWorld(), pos.getX(), pos.getY(), pos.getZ());
     }
 
+    // Folia start - TODO MERGE INTO MCUTIL
+    /**
+     * Converts a NMS World/Vector to Bukkit Location
+     * @param world
+     * @param pos
+     * @return
+     */
+    public static Location toLocation(Level world, Vec3 pos) {
+        return new Location(world.getWorld(), pos.x(), pos.y(), pos.z());
+    }
+
+    /**
+     * Converts a NMS World/Vector to Bukkit Location
+     * @param world
+     * @param pos
+     * @param yaw
+     * @param pitch
+     * @return
+     */
+    public static Location toLocation(Level world, Vec3 pos, float yaw, float pitch) {
+        return new Location(world.getWorld(), pos.x(), pos.y(), pos.z(), yaw, pitch);
+    }
+    // Folia end - TODO MERGE INTO MCUTIL
+
     public static BlockPos toBlockPosition(Location loc) {
         return new BlockPos(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ());
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index fda9daa6369933c80051ae007ba89513aa19227c..f12ac98285a18ce30fd5593aba9c0ef0b65622c5 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -315,7 +315,7 @@ public final class CraftServer implements Server {
     public final io.papermc.paper.SparksFly spark; // Paper - spark
 
     // Paper start - Folia region threading API
-    private final io.papermc.paper.threadedregions.scheduler.FallbackRegionScheduler regionizedScheduler = new io.papermc.paper.threadedregions.scheduler.FallbackRegionScheduler();
+    private final io.papermc.paper.threadedregions.scheduler.FoliaRegionScheduler regionizedScheduler = new io.papermc.paper.threadedregions.scheduler.FoliaRegionScheduler(); // Folia - region threading
     private final io.papermc.paper.threadedregions.scheduler.FoliaAsyncScheduler asyncScheduler = new io.papermc.paper.threadedregions.scheduler.FoliaAsyncScheduler();
     private final io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler globalRegionScheduler = new io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler();
 
@@ -392,7 +392,7 @@ public final class CraftServer implements Server {
 
     @Override
     public final boolean isGlobalTickThread() {
-        return ca.spottedleaf.moonrise.common.util.TickThread.isTickThread();
+        return io.papermc.paper.threadedregions.RegionizedServer.isGlobalTickThread(); // Folia - region threading API
     }
     // Paper end - Folia reagion threading API
 
@@ -987,6 +987,9 @@ public final class CraftServer implements Server {
 
     // NOTE: Should only be called from DedicatedServer.ah()
     public boolean dispatchServerCommand(CommandSender sender, ConsoleInput serverCommand) {
+        // Folia start - region threading
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("May not dispatch server commands async");
+        // Folia end - region threading
         if (sender instanceof Conversable) {
             Conversable conversable = (Conversable) sender;
 
@@ -1006,12 +1009,46 @@ public final class CraftServer implements Server {
         }
     }
 
+    // Folia start - region threading
+    public void dispatchCmdAsync(CommandSender sender, String commandLine) {
+        if ((sender instanceof Entity entity)) {
+            ((org.bukkit.craftbukkit.entity.CraftEntity)entity).taskScheduler.schedule(
+                (nmsEntity) -> {
+                    CraftServer.this.dispatchCommand(nmsEntity.getBukkitEntity(), commandLine);
+                },
+                null,
+                1L
+            );
+        } else if (sender instanceof ConsoleCommandSender || sender instanceof io.papermc.paper.commands.FeedbackForwardingSender) {
+            io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> {
+                CraftServer.this.dispatchCommand(sender, commandLine);
+            });
+        } else {
+            // huh?
+            throw new UnsupportedOperationException("Dispatching command for " + sender);
+        }
+    }
+    // Folia end - region threading
+
     @Override
     public boolean dispatchCommand(CommandSender sender, String commandLine) {
         Preconditions.checkArgument(sender != null, "sender cannot be null");
         Preconditions.checkArgument(commandLine != null, "commandLine cannot be null");
         org.spigotmc.AsyncCatcher.catchOp("Command Dispatched Async: " + commandLine); // Spigot // Paper - Include command in error message
 
+        // Folia start - region threading
+        if ((sender instanceof Entity entity)) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(((org.bukkit.craftbukkit.entity.CraftEntity)entity).getHandle(), "Dispatching command async");
+        } else if (sender instanceof ConsoleCommandSender || sender instanceof net.minecraft.server.rcon.RconConsoleSource
+                    || sender instanceof org.bukkit.craftbukkit.command.CraftRemoteConsoleCommandSender
+                    || sender instanceof io.papermc.paper.commands.FeedbackForwardingSender) {
+            io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Dispatching command async");
+        } else {
+            // huh?
+            throw new UnsupportedOperationException("Dispatching command for " + sender);
+        }
+        // Folia end - region threading
+
         if (this.commandMap.dispatch(sender, commandLine)) {
             return true;
         }
@@ -3252,7 +3289,7 @@ public final class CraftServer implements Server {
 
     @Override
     public int getCurrentTick() {
-        return net.minecraft.server.MinecraftServer.currentTick;
+        return (int)io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick(); // Folia - region threading
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 28196931453c6c65599d33915130fdfe009f1d11..3d7dd06f4d0b612f04d0f9a627c7d8215f50d915 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -228,7 +228,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public int getTickableTileEntityCount() {
-        return world.blockEntityTickers.size();
+        throw new UnsupportedOperationException(); // Folia - region threading - TODO fix this?
     }
 
     @Override
@@ -295,7 +295,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         // Paper start - per world spawn limits
         for (SpawnCategory spawnCategory : SpawnCategory.values()) {
             if (CraftSpawnCategory.isValidForLimits(spawnCategory)) {
-                setSpawnLimit(spawnCategory, this.world.paperConfig().entities.spawning.spawnLimits.getInt(CraftSpawnCategory.toNMS(spawnCategory)));
+                this.spawnCategoryLimit.put(spawnCategory, this.world.paperConfig().entities.spawning.spawnLimits.getInt(CraftSpawnCategory.toNMS(spawnCategory))); // Folia - region threading
             }
         }
         // Paper end - per world spawn limits
@@ -365,6 +365,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public Chunk getChunkAt(int x, int z) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.getHandle(), x, z, "Async chunk retrieval"); // Folia - region threading
         warnUnsafeChunk("getting a faraway chunk", x, z); // Paper
         net.minecraft.world.level.chunk.LevelChunk chunk = (net.minecraft.world.level.chunk.LevelChunk) this.world.getChunk(x, z, ChunkStatus.FULL, true);
         return new CraftChunk(chunk);
@@ -395,10 +396,10 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public boolean isChunkGenerated(int x, int z) {
         // Paper start - Fix this method
-        if (!Bukkit.isPrimaryThread()) {
+        if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.getHandle(), x, z)) { // Folia - region threading
             return java.util.concurrent.CompletableFuture.supplyAsync(() -> {
                 return CraftWorld.this.isChunkGenerated(x, z);
-            }, world.getChunkSource().mainThreadProcessor).join();
+            }, (run) -> { io.papermc.paper.threadedregions.RegionizedServer.getInstance().taskQueue.queueChunkTask(this.getHandle(), x, z, run);}).join(); // Folia - region threading
         }
         ChunkAccess chunk = world.getChunkSource().getChunkAtImmediately(x, z);
         if (chunk != null) {
@@ -455,7 +456,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     }
 
     private boolean unloadChunk0(int x, int z, boolean save) {
-        org.spigotmc.AsyncCatcher.catchOp("chunk unload"); // Spigot
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x, z, "Cannot unload chunk asynchronously"); // Folia - region threading
         if (!this.isChunkLoaded(x, z)) {
             return true;
         }
@@ -472,7 +473,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean regenerateChunk(int x, int z) {
-        org.spigotmc.AsyncCatcher.catchOp("chunk regenerate"); // Spigot
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x, z, "Cannot regenerate chunk asynchronously"); // Folia - region threading
         throw new UnsupportedOperationException("Not supported in this Minecraft version! Unless you can fix it, this is not a bug :)");
         /*
         if (!unloadChunk0(x, z, false)) {
@@ -499,6 +500,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean refreshChunk(int x, int z) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x, z, "Cannot refresh chunk asynchronously"); // Folia - region threading
         ChunkHolder playerChunk = this.world.getChunkSource().chunkMap.getVisibleChunkIfPresent(ChunkPos.asLong(x, z));
         if (playerChunk == null) return false;
 
@@ -549,7 +551,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean loadChunk(int x, int z, boolean generate) {
-        org.spigotmc.AsyncCatcher.catchOp("chunk load"); // Spigot
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.getHandle(), x, z, "May not sync load chunks asynchronously"); // Folia - region threading
         warnUnsafeChunk("loading a faraway chunk", x, z); // Paper
         ChunkAccess chunk = this.world.getChunkSource().getChunk(x, z, generate || isChunkGenerated(x, z) ? ChunkStatus.FULL : ChunkStatus.EMPTY, true); // Paper
 
@@ -589,7 +591,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
         final DistanceManager distanceManager = this.world.getChunkSource().chunkMap.distanceManager;
         if (distanceManager.addPluginRegionTicket(new ChunkPos(x, z), plugin)) {
-            this.getChunkAt(x, z); // ensure it's loaded
+            //this.getChunkAt(x, z); // ensure it's loaded // Folia - region threading - do not load chunks for tickets anymore to make this mt-safe
             return true;
         }
 
@@ -777,13 +779,15 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
-        this.world.captureTreeGeneration = true;
-        this.world.captureBlockStates = true;
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, loc.getX(), loc.getZ(), "Cannot generate tree asynchronously"); // Folia - region threading
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = world.getCurrentWorldData(); // Folia - region threading
+        worldData.captureTreeGeneration = true; // Folia - region threading
+        worldData.captureBlockStates = true; // Folia - region threading
         boolean grownTree = this.generateTree(loc, type);
-        this.world.captureBlockStates = false;
-        this.world.captureTreeGeneration = false;
+        worldData.captureBlockStates = false; // Folia - region threading
+        worldData.captureTreeGeneration = false; // Folia - region threading
         if (grownTree) { // Copy block data to delegate
-            for (BlockState blockstate : this.world.capturedBlockStates.values()) {
+            for (BlockState blockstate : worldData.capturedBlockStates.values()) { // Folia - region threading
                 BlockPos position = ((CraftBlockState) blockstate).getPosition();
                 net.minecraft.world.level.block.state.BlockState oldBlock = this.world.getBlockState(position);
                 int flag = ((CraftBlockState) blockstate).getFlag();
@@ -791,10 +795,10 @@ public class CraftWorld extends CraftRegionAccessor implements World {
                 net.minecraft.world.level.block.state.BlockState newBlock = this.world.getBlockState(position);
                 this.world.notifyAndUpdatePhysics(position, null, oldBlock, newBlock, newBlock, flag, 512);
             }
-            this.world.capturedBlockStates.clear();
+            worldData.capturedBlockStates.clear(); // Folia - region threading
             return true;
         } else {
-            this.world.capturedBlockStates.clear();
+            worldData.capturedBlockStates.clear(); // Folia - region threading
             return false;
         }
     }
@@ -828,6 +832,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setTime(long time) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify time off of the global region"); // Folia - region threading
         long margin = (time - this.getFullTime()) % 24000;
         if (margin < 0) margin += 24000;
         this.setFullTime(this.getFullTime() + margin);
@@ -840,6 +845,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setFullTime(long time) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify time off of the global region"); // Folia - region threading
         // Notify anyone who's listening
         TimeSkipEvent event = new TimeSkipEvent(this, TimeSkipEvent.SkipReason.CUSTOM, time - this.world.getDayTime());
         this.server.getPluginManager().callEvent(event);
@@ -867,7 +873,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public long getGameTime() {
-        return this.world.levelData.getGameTime();
+        return this.getHandle().getGameTime(); // Folia - region threading
     }
 
     @Override
@@ -892,6 +898,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     }
     public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks, Entity source, Consumer<net.minecraft.world.level.ServerExplosion> configurator) {
     // Paper end - expand explosion API
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x, z, "Cannot create explosion asynchronously"); // Folia - region threading
         net.minecraft.world.level.Level.ExplosionInteraction explosionType;
         if (!breakBlocks) {
             explosionType = net.minecraft.world.level.Level.ExplosionInteraction.NONE; // Don't break blocks
@@ -901,6 +908,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             explosionType = net.minecraft.world.level.Level.ExplosionInteraction.MOB; // Respect mobGriefing gamerule
         }
 
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x, z, "Cannot create explosion asynchronously"); // Folia - region threading
         net.minecraft.world.entity.Entity entity = (source == null) ? null : ((CraftEntity) source).getHandle();
         return !this.world.explode0(entity, Explosion.getDefaultDamageSource(this.world, entity), null, x, y, z, power, setFire, explosionType, ParticleTypes.EXPLOSION, ParticleTypes.EXPLOSION_EMITTER, SoundEvents.GENERIC_EXPLODE, configurator).wasCanceled; // Paper - expand explosion API
     }
@@ -983,6 +991,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public int getHighestBlockYAt(int x, int z, org.bukkit.HeightMap heightMap) {
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x >> 4, z >> 4, "Cannot retrieve chunk asynchronously"); // Folia - region threading
         warnUnsafeChunk("getting a faraway chunk", x >> 4, z >> 4); // Paper
         // Transient load for this tick
         return this.world.getChunk(x >> 4, z >> 4).getHeight(CraftHeightMap.toNMS(heightMap), x, z);
@@ -1013,6 +1022,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public void setBiome(int x, int y, int z, Holder<net.minecraft.world.level.biome.Biome> bb) {
         BlockPos pos = new BlockPos(x, 0, z);
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, pos, "Cannot retrieve chunk asynchronously"); // Folia - region threading
         if (this.world.hasChunkAt(pos)) {
             net.minecraft.world.level.chunk.LevelChunk chunk = this.world.getChunkAt(pos);
 
@@ -1323,6 +1333,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setStorm(boolean hasStorm) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setRaining(hasStorm, org.bukkit.event.weather.WeatherChangeEvent.Cause.PLUGIN); // Paper - Add cause to Weather/ThunderChangeEvents
         this.setWeatherDuration(0); // Reset weather duration (legacy behaviour)
         this.setClearWeatherDuration(0); // Reset clear weather duration (reset "/weather clear" commands)
@@ -1335,6 +1346,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setWeatherDuration(int duration) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setRainTime(duration);
     }
 
@@ -1345,6 +1357,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setThundering(boolean thundering) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setThundering(thundering, org.bukkit.event.weather.ThunderChangeEvent.Cause.PLUGIN); // Paper - Add cause to Weather/ThunderChangeEvents
         this.setThunderDuration(0); // Reset weather duration (legacy behaviour)
         this.setClearWeatherDuration(0); // Reset clear weather duration (reset "/weather clear" commands)
@@ -1357,6 +1370,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setThunderDuration(int duration) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setThunderTime(duration);
     }
 
@@ -1367,6 +1381,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setClearWeatherDuration(int duration) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify weather off of the global region"); // Folia - region threading
         this.world.serverLevelData.setClearWeatherTime(duration);
     }
 
@@ -1565,6 +1580,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setKeepSpawnInMemory(boolean keepLoaded) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify keep spawn in memory off of the global region"); // Folia - region threading
         if (keepLoaded) {
             this.setGameRule(GameRule.SPAWN_CHUNK_RADIUS, this.getGameRuleDefault(GameRule.SPAWN_CHUNK_RADIUS));
         } else {
@@ -1633,6 +1649,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setHardcore(boolean hardcore) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.world.serverLevelData.settings.hardcore = hardcore;
     }
 
@@ -1645,6 +1662,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.ANIMAL, ticksPerAnimalSpawns);
     }
 
@@ -1657,6 +1675,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.MONSTER, ticksPerMonsterSpawns);
     }
 
@@ -1669,6 +1688,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerWaterSpawns(int ticksPerWaterSpawns) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.WATER_ANIMAL, ticksPerWaterSpawns);
     }
 
@@ -1681,6 +1701,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerWaterAmbientSpawns(int ticksPerWaterAmbientSpawns) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.WATER_AMBIENT, ticksPerWaterAmbientSpawns);
     }
 
@@ -1693,6 +1714,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerWaterUndergroundCreatureSpawns(int ticksPerWaterUndergroundCreatureSpawns) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.WATER_UNDERGROUND_CREATURE, ticksPerWaterUndergroundCreatureSpawns);
     }
 
@@ -1705,11 +1727,13 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setTicksPerAmbientSpawns(int ticksPerAmbientSpawns) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setTicksPerSpawns(SpawnCategory.AMBIENT, ticksPerAmbientSpawns);
     }
 
     @Override
     public void setTicksPerSpawns(SpawnCategory spawnCategory, int ticksPerCategorySpawn) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         Preconditions.checkArgument(spawnCategory != null, "SpawnCategory cannot be null");
         Preconditions.checkArgument(CraftSpawnCategory.isValidForLimits(spawnCategory), "SpawnCategory.%s are not supported", spawnCategory);
 
@@ -1726,21 +1750,25 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify metadata off of the global region"); // Folia - region threading
         this.server.getWorldMetadata().setMetadata(this, metadataKey, newMetadataValue);
     }
 
     @Override
     public List<MetadataValue> getMetadata(String metadataKey) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot retrieve metadata off of the global region"); // Folia - region threading
         return this.server.getWorldMetadata().getMetadata(this, metadataKey);
     }
 
     @Override
     public boolean hasMetadata(String metadataKey) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot retrieve metadata off of the global region"); // Folia - region threading
         return this.server.getWorldMetadata().hasMetadata(this, metadataKey);
     }
 
     @Override
     public void removeMetadata(String metadataKey, Plugin owningPlugin) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify metadata off of the global region"); // Folia - region threading
         this.server.getWorldMetadata().removeMetadata(this, metadataKey, owningPlugin);
     }
 
@@ -1753,6 +1781,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setMonsterSpawnLimit(int limit) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.MONSTER, limit);
     }
 
@@ -1765,6 +1794,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setAnimalSpawnLimit(int limit) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.ANIMAL, limit);
     }
 
@@ -1777,6 +1807,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setWaterAnimalSpawnLimit(int limit) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.WATER_ANIMAL, limit);
     }
 
@@ -1789,6 +1820,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setWaterAmbientSpawnLimit(int limit) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.WATER_AMBIENT, limit);
     }
 
@@ -1801,6 +1833,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setWaterUndergroundCreatureSpawnLimit(int limit) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.WATER_UNDERGROUND_CREATURE, limit);
     }
 
@@ -1813,6 +1846,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     @Deprecated
     public void setAmbientSpawnLimit(int limit) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         this.setSpawnLimit(SpawnCategory.AMBIENT, limit);
     }
 
@@ -1835,6 +1869,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void setSpawnLimit(SpawnCategory spawnCategory, int limit) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         Preconditions.checkArgument(spawnCategory != null, "SpawnCategory cannot be null");
         Preconditions.checkArgument(CraftSpawnCategory.isValidForLimits(spawnCategory), "SpawnCategory.%s are not supported", spawnCategory);
 
@@ -1917,7 +1952,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         if (!(entity instanceof CraftEntity craftEntity) || entity.getWorld() != this || sound == null || category == null) return;
 
         ClientboundSoundEntityPacket packet = new ClientboundSoundEntityPacket(CraftSound.bukkitToMinecraftHolder(sound), net.minecraft.sounds.SoundSource.valueOf(category.name()), craftEntity.getHandle(), volume, pitch, seed);
-        ChunkMap.TrackedEntity entityTracker = this.getHandle().getChunkSource().chunkMap.entityMap.get(entity.getEntityId());
+        ChunkMap.TrackedEntity entityTracker = ((CraftEntity) entity).getHandle().moonrise$getTrackedEntity(); // Folia - region threading
         if (entityTracker != null) {
             entityTracker.broadcastAndSend(packet);
         }
@@ -1938,7 +1973,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
         if (!(entity instanceof CraftEntity craftEntity) || entity.getWorld() != this || sound == null || category == null) return;
 
         ClientboundSoundEntityPacket packet = new ClientboundSoundEntityPacket(Holder.direct(SoundEvent.createVariableRangeEvent(ResourceLocation.parse(sound))), net.minecraft.sounds.SoundSource.valueOf(category.name()), craftEntity.getHandle(), volume, pitch, seed);
-        ChunkMap.TrackedEntity entityTracker = this.getHandle().getChunkSource().chunkMap.entityMap.get(entity.getEntityId());
+        ChunkMap.TrackedEntity entityTracker = ((CraftEntity)entity).getHandle().moonrise$getTrackedEntity(); // Folia - region threading
         if (entityTracker != null) {
             entityTracker.broadcastAndSend(packet);
         }
@@ -2021,6 +2056,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean setGameRuleValue(String rule, String value) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         // No null values allowed
         if (rule == null || value == null) return false;
 
@@ -2063,6 +2099,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public <T> boolean setGameRule(GameRule<T> rule, T newValue) {
+        io.papermc.paper.threadedregions.RegionizedServer.ensureGlobalTickThread("Cannot modify server settings off of the global region"); // Folia - region threading
         Preconditions.checkArgument(rule != null, "GameRule cannot be null");
         Preconditions.checkArgument(newValue != null, "GameRule value cannot be null");
 
@@ -2290,6 +2327,12 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void sendGameEvent(Entity sourceEntity, org.bukkit.GameEvent gameEvent, Vector position) {
+        // Folia start - region threading
+        if (sourceEntity != null && !Bukkit.isOwnedByCurrentRegion(sourceEntity)) {
+            throw new IllegalStateException("Cannot send game event asynchronously");
+        }
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, position.getX(), position.getZ(), "Cannot send game event asynchronously");
+        // Folia end - region threading
         getHandle().gameEvent(sourceEntity != null ? ((CraftEntity) sourceEntity).getHandle(): null, net.minecraft.core.registries.BuiltInRegistries.GAME_EVENT.get(org.bukkit.craftbukkit.util.CraftNamespacedKey.toMinecraft(gameEvent.getKey())).orElseThrow(), org.bukkit.craftbukkit.util.CraftVector.toBlockPos(position));
     }
     // Paper end
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index 5cb69d0b822e11a99a96aef4f59986d083b079f4..a2f35f6d057b098a016a40094d84c54cb5e174fd 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -75,6 +75,11 @@ public class CraftBlock implements Block {
     }
 
     public net.minecraft.world.level.block.state.BlockState getNMS() {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         return this.world.getBlockState(this.position);
     }
 
@@ -157,6 +162,11 @@ public class CraftBlock implements Block {
     }
 
     private void setData(final byte data, int flag) {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         this.world.setBlock(this.position, CraftMagicNumbers.getBlock(this.getType(), data), flag);
     }
 
@@ -198,6 +208,11 @@ public class CraftBlock implements Block {
     }
 
     public static boolean setTypeAndData(LevelAccessor world, BlockPos position, net.minecraft.world.level.block.state.BlockState old, net.minecraft.world.level.block.state.BlockState blockData, boolean applyPhysics) {
+        // Folia start - region threading
+        if (world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+        }
+        // Folia end - region threading
         // SPIGOT-611: need to do this to prevent glitchiness. Easier to handle this here (like /setblock) than to fix weirdness in tile entity cleanup
         if (old.hasBlockEntity() && blockData.getBlock() != old.getBlock()) { // SPIGOT-3725 remove old tile entity if block changes
             // SPIGOT-4612: faster - just clear tile
@@ -343,18 +358,33 @@ public class CraftBlock implements Block {
 
     @Override
     public Biome getBiome() {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         return this.getWorld().getBiome(this.getX(), this.getY(), this.getZ());
     }
 
     // Paper start
     @Override
     public Biome getComputedBiome() {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         return this.getWorld().getComputedBiome(this.getX(), this.getY(), this.getZ());
     }
     // Paper end
 
     @Override
     public void setBiome(Biome bio) {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         this.getWorld().setBiome(this.getX(), this.getY(), this.getZ(), bio);
     }
 
@@ -402,6 +432,11 @@ public class CraftBlock implements Block {
 
     @Override
     public boolean isBlockFaceIndirectlyPowered(BlockFace face) {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         int power = this.world.getMinecraftWorld().getSignal(this.position, CraftBlock.blockFaceToNotch(face));
 
         Block relative = this.getRelative(face);
@@ -414,6 +449,11 @@ public class CraftBlock implements Block {
 
     @Override
     public int getBlockPower(BlockFace face) {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         int power = 0;
         net.minecraft.world.level.Level world = this.world.getMinecraftWorld();
         int x = this.getX();
@@ -500,6 +540,11 @@ public class CraftBlock implements Block {
 
     @Override
     public boolean breakNaturally(ItemStack item, boolean triggerEffect, boolean dropExperience) {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         // Paper end
         // Order matters here, need to drop before setting to air so skulls can get their data
         net.minecraft.world.level.block.state.BlockState iblockdata = this.getNMS();
@@ -543,21 +588,27 @@ public class CraftBlock implements Block {
 
     @Override
     public boolean applyBoneMeal(BlockFace face) {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         Direction direction = CraftBlock.blockFaceToNotch(face);
         BlockFertilizeEvent event = null;
         ServerLevel world = this.getCraftWorld().getHandle();
         UseOnContext context = new UseOnContext(world, null, InteractionHand.MAIN_HAND, Items.BONE_MEAL.getDefaultInstance(), new BlockHitResult(Vec3.ZERO, direction, this.getPosition(), false));
 
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = world.getCurrentWorldData(); // Folia - region threading
         // SPIGOT-6895: Call StructureGrowEvent and BlockFertilizeEvent
-        world.captureTreeGeneration = true;
+        worldData.captureTreeGeneration = true; // Folia - region threading
         InteractionResult result = BoneMealItem.applyBonemeal(context);
-        world.captureTreeGeneration = false;
+        worldData.captureTreeGeneration = false; // Folia - region threading
 
-        if (world.capturedBlockStates.size() > 0) {
-            TreeType treeType = SaplingBlock.treeType;
-            SaplingBlock.treeType = null;
-            List<BlockState> blocks = new ArrayList<>(world.capturedBlockStates.values());
-            world.capturedBlockStates.clear();
+        if (worldData.capturedBlockStates.size() > 0) { // Folia - region threading
+            TreeType treeType = SaplingBlock.treeTypeRT.get(); // Folia - region threading
+            SaplingBlock.treeTypeRT.set(null); // Folia - region threading
+            List<BlockState> blocks = new ArrayList<>(worldData.capturedBlockStates.values()); // Folia - region threading
+            worldData.capturedBlockStates.clear(); // Folia - region threading
             StructureGrowEvent structureEvent = null;
 
             if (treeType != null) {
@@ -644,6 +695,11 @@ public class CraftBlock implements Block {
 
     @Override
     public RayTraceResult rayTrace(Location start, Vector direction, double maxDistance, FluidCollisionMode fluidCollisionMode) {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         Preconditions.checkArgument(start != null, "Location start cannot be null");
         Preconditions.checkArgument(this.getWorld().equals(start.getWorld()), "Location start cannot be a different world");
         start.checkFinite();
@@ -685,6 +741,11 @@ public class CraftBlock implements Block {
 
     @Override
     public boolean canPlace(BlockData data) {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         Preconditions.checkArgument(data != null, "BlockData cannot be null");
         net.minecraft.world.level.block.state.BlockState iblockdata = ((CraftBlockData) data).getState();
         net.minecraft.world.level.Level world = this.world.getMinecraftWorld();
@@ -719,18 +780,32 @@ public class CraftBlock implements Block {
 
     @Override
     public void tick() {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         final ServerLevel level = this.world.getMinecraftWorld();
         this.getNMS().tick(level, this.position, level.random);
     }
 
-
     @Override
     public void fluidTick() {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         this.getNMSFluid().tick(this.world.getMinecraftWorld(), this.position, this.getNMS());
     }
 
     @Override
     public void randomTick() {
+        // Folia start - region threading
+        if (this.world instanceof ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, this.position, "Cannot read world asynchronously");
+        }
+        // Folia end - region threading
         final ServerLevel level = this.world.getMinecraftWorld();
         this.getNMS().randomTick(level, this.position, level.random);
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
index 04ae258a2f8e98421340d29d5cceedec045171b7..698a87ac30cc9efabeef3344ee254bcace1256c9 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
@@ -25,7 +25,7 @@ public abstract class CraftBlockEntityState<T extends BlockEntity> extends Craft
     private final T tileEntity;
     private final T snapshot;
     public boolean snapshotDisabled; // Paper
-    public static boolean DISABLE_SNAPSHOT = false; // Paper
+    public static final ThreadLocal<Boolean> DISABLE_SNAPSHOT = ThreadLocal.withInitial(() -> Boolean.FALSE); // Paper // Folia - region threading
 
     public CraftBlockEntityState(World world, T tileEntity) {
         super(world, tileEntity.getBlockPos(), tileEntity.getBlockState());
@@ -34,8 +34,8 @@ public abstract class CraftBlockEntityState<T extends BlockEntity> extends Craft
 
         try { // Paper - Show blockstate location if we failed to read it
         // Paper start
-        this.snapshotDisabled = DISABLE_SNAPSHOT;
-        if (DISABLE_SNAPSHOT) {
+        this.snapshotDisabled = DISABLE_SNAPSHOT.get().booleanValue(); // Folia - region threading
+        if (this.snapshotDisabled) { // Folia - region threading
             this.snapshot = this.tileEntity;
         } else {
             this.snapshot = this.createSnapshot(tileEntity);
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
index fa63a6cfcfcc4eee4503a82d85333c139c8c8b2b..def7749e6dc4ae8351b72deefc75936629c33d7f 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
@@ -215,6 +215,12 @@ public class CraftBlockState implements BlockState {
         LevelAccessor access = this.getWorldHandle();
         CraftBlock block = this.getBlock();
 
+        // Folia start - region threading
+        if (access instanceof net.minecraft.server.level.ServerLevel serverWorld) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverWorld, position, "Cannot modify world asynchronously");
+        }
+        // Folia end - region threading
+
         if (block.getType() != this.getType()) {
             if (!force) {
                 return false;
@@ -350,6 +356,9 @@ public class CraftBlockState implements BlockState {
 
     @Override
     public java.util.Collection<org.bukkit.inventory.ItemStack> getDrops(org.bukkit.inventory.ItemStack item, org.bukkit.entity.Entity entity) {
+        // Folia start - region threading
+        ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(world.getHandle(), position, "Cannot modify world asynchronously");
+        // Folia end - region threading
         this.requirePlaced();
         net.minecraft.world.item.ItemStack nms = org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(item);
 
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java
index 56453454cbd4b9e9270fc833f8ab38d5fa7a3763..69e8a170a80c2fde79bc015cd54879896c110d9d 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java
@@ -249,8 +249,8 @@ public final class CraftBlockStates {
         net.minecraft.world.level.block.state.BlockState blockData = craftBlock.getNMS();
         BlockEntity tileEntity = craftBlock.getHandle().getBlockEntity(blockPosition);
         // Paper start - block state snapshots
-        boolean prev = CraftBlockEntityState.DISABLE_SNAPSHOT;
-        CraftBlockEntityState.DISABLE_SNAPSHOT = !useSnapshot;
+        boolean prev = CraftBlockEntityState.DISABLE_SNAPSHOT.get().booleanValue(); // Folia - region threading
+        CraftBlockEntityState.DISABLE_SNAPSHOT.set(Boolean.valueOf(!useSnapshot)); // Folia - region threading
         try {
         // Paper end
         CraftBlockState blockState = CraftBlockStates.getBlockState(world, blockPosition, blockData, tileEntity);
@@ -258,7 +258,7 @@ public final class CraftBlockStates {
         return blockState;
         // Paper start
         } finally {
-            CraftBlockEntityState.DISABLE_SNAPSHOT = prev;
+            CraftBlockEntityState.DISABLE_SNAPSHOT.set(Boolean.valueOf(prev)); // Folia - region threading
         }
         // Paper end
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ConsoleCommandCompleter.java b/src/main/java/org/bukkit/craftbukkit/command/ConsoleCommandCompleter.java
index a45e658996e483e9a21cfd8178153ddb7b87ae69..25303f144422469350fdc6f84320b16bcc9f6e0c 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ConsoleCommandCompleter.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ConsoleCommandCompleter.java
@@ -50,7 +50,7 @@ public class ConsoleCommandCompleter implements Completer {
                         return syncEvent.callEvent() ? syncEvent.getCompletions() : com.google.common.collect.ImmutableList.of();
                     }
                 };
-                server.getServer().processQueue.add(syncCompletions);
+                io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(syncCompletions); // Folia - region threading
                 try {
                     final List<String> legacyCompletions = syncCompletions.get();
                     completions.removeIf(it -> !legacyCompletions.contains(it.suggestion())); // remove any suggestions that were removed
@@ -98,7 +98,7 @@ public class ConsoleCommandCompleter implements Completer {
                 return tabEvent.isCancelled() ? Collections.EMPTY_LIST : tabEvent.getCompletions();
             }
         };
-        server.getServer().processQueue.add(waitable); // Paper - Remove "this."
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(waitable); // Folia - region threading
         try {
             List<String> offers = waitable.get();
             if (offers == null) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 4562bee2e2795801862bae03d783799fc076b73e..e0ed7e9501bcf95c9bf7480f766738ed694295b0 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -82,6 +82,11 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return this.apiScheduler;
     };
     // Paper end - Folia schedulers
+    // Folia start - region threading
+    public boolean isPurged() {
+        return this.taskScheduler.isRetired();
+    }
+    // Folia end - region threading
 
     public CraftEntity(final CraftServer server, final Entity entity) {
         this.server = server;
@@ -239,6 +244,11 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
     @Override
     public boolean teleport(Location location, TeleportCause cause, io.papermc.paper.entity.TeleportFlag... flags) {
+        // Folia start - region threading
+        if (true) {
+            throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
+        }
+        // Folia end - region threading
         // Paper end
         Preconditions.checkArgument(location != null, "location cannot be null");
         location.checkFinite();
@@ -722,7 +732,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         ImmutableSet.Builder<Player> players = ImmutableSet.builder();
 
         ServerLevel world = ((CraftWorld) this.getWorld()).getHandle();
-        ChunkMap.TrackedEntity entityTracker = world.getChunkSource().chunkMap.entityMap.get(this.getEntityId());
+        ChunkMap.TrackedEntity entityTracker = this.getHandle().moonrise$getTrackedEntity(); // Folia - region threading
 
         if (entityTracker != null) {
             for (ServerPlayerConnection connection : entityTracker.seenBy) {
@@ -1026,7 +1036,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         }
 
         ServerLevel world = ((CraftWorld) this.getWorld()).getHandle();
-        ChunkMap.TrackedEntity entityTracker = world.getChunkSource().chunkMap.entityMap.get(this.getEntityId());
+        ChunkMap.TrackedEntity entityTracker = this.getHandle().moonrise$getTrackedEntity(); // Folia - region threading
 
         if (entityTracker == null) {
             return;
@@ -1045,7 +1055,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         }
 
         ServerLevel world = ((CraftWorld) this.getWorld()).getHandle();
-        ChunkMap.TrackedEntity entityTracker = world.getChunkSource().chunkMap.entityMap.get(this.getEntityId());
+        ChunkMap.TrackedEntity entityTracker = this.entity.moonrise$getTrackedEntity(); // Folia - region threading
 
         if (entityTracker == null) {
             return;
@@ -1079,29 +1089,43 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         location.checkFinite();
         Location locationClone = location.clone(); // clone so we don't need to worry about mutations after this call.
 
-        net.minecraft.server.level.ServerLevel world = ((CraftWorld)locationClone.getWorld()).getHandle();
+        // Folia start - region threading
         java.util.concurrent.CompletableFuture<Boolean> ret = new java.util.concurrent.CompletableFuture<>();
-
-        world.loadChunksForMoveAsync(getHandle().getBoundingBoxAt(locationClone.getX(), locationClone.getY(), locationClone.getZ()),
-            this instanceof CraftPlayer ? ca.spottedleaf.concurrentutil.util.Priority.HIGHER : ca.spottedleaf.concurrentutil.util.Priority.NORMAL, (list) -> {
-                net.minecraft.server.MinecraftServer.getServer().scheduleOnMain(() -> {
-                    final net.minecraft.server.level.ServerChunkCache chunkCache = world.getChunkSource();
-                    for (final net.minecraft.world.level.chunk.ChunkAccess chunk : list) {
-                        chunkCache.addTicketAtLevel(net.minecraft.server.level.TicketType.POST_TELEPORT, chunk.getPos(), 33, CraftEntity.this.getEntityId());
-                    }
-                    try {
-                        ret.complete(CraftEntity.this.teleport(locationClone, cause, teleportFlags) ? Boolean.TRUE : Boolean.FALSE);
-                    } catch (Throwable throwable) {
-                        if (throwable instanceof ThreadDeath) {
-                            throw (ThreadDeath)throwable;
-                        }
-                        net.minecraft.server.MinecraftServer.LOGGER.error("Failed to teleport entity " + CraftEntity.this, throwable);
-                        ret.completeExceptionally(throwable);
-                    }
-                });
-            });
+        java.util.function.Consumer<Entity> run = (Entity nmsEntity) -> {
+            boolean success = nmsEntity.teleportAsync(
+                ((CraftWorld)locationClone.getWorld()).getHandle(),
+                new net.minecraft.world.phys.Vec3(locationClone.getX(), locationClone.getY(), locationClone.getZ()),
+                locationClone.getYaw(), locationClone.getPitch(), net.minecraft.world.phys.Vec3.ZERO,
+                cause == null ? TeleportCause.UNKNOWN : cause,
+                Entity.TELEPORT_FLAG_LOAD_CHUNK | Entity.TELEPORT_FLAG_TELEPORT_PASSENGERS, // preserve behavior with old API: dismount the entity so it can teleport
+                (Entity entityTp) -> {
+                    ret.complete(Boolean.TRUE);
+                }
+            );
+            if (!success) {
+                ret.complete(Boolean.FALSE);
+            }
+        };
+        if (org.bukkit.Bukkit.isOwnedByCurrentRegion(this)) {
+            run.accept(this.getHandle());
+            return ret;
+        }
+        boolean scheduled = this.taskScheduler.schedule(
+            // success
+            run,
+            // retired
+            (Entity nmsEntity) -> {
+                ret.complete(Boolean.FALSE);
+            },
+            1L
+        );
+
+        if (!scheduled) {
+            ret.complete(Boolean.FALSE);
+        }
 
         return ret;
+        // Folia end - region threading
     }
     // Paper end - more teleport API / async chunk API
 
@@ -1214,8 +1238,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     // Paper start - tracked players API
     @Override
     public Set<org.bukkit.entity.Player> getTrackedPlayers() {
-        ServerLevel world = (net.minecraft.server.level.ServerLevel)this.entity.level();
-        ChunkMap.TrackedEntity tracker = world == null ? null : world.getChunkSource().chunkMap.entityMap.get(this.entity.getId());
+        ChunkMap.TrackedEntity tracker = this.entity.moonrise$getTrackedEntity(); // Folia - region threading
         if (tracker == null) {
             return java.util.Collections.emptySet();
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 98fc89cc7a715d35b62e13f8ecbe56c05605ca64..89633d88be288e8caba846c49c6267e45fcadc06 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -666,7 +666,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public void kickPlayer(String message) {
-        org.spigotmc.AsyncCatcher.catchOp("player kick"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp("player kick"); // Spigot // Folia - thread-safe now, as it will simply delay the kick
         this.getHandle().transferCookieConnection.kickPlayer(CraftChatMessage.fromStringOrEmpty(message, true), org.bukkit.event.player.PlayerKickEvent.Cause.PLUGIN); // Paper - kick event cause
     }
 
@@ -1403,6 +1403,11 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public boolean teleport(Location location, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause, io.papermc.paper.entity.TeleportFlag... flags) {
+        // Folia start - region threading
+        if (true) {
+            throw new UnsupportedOperationException("Must use teleportAsync while in region threading");
+        }
+        // Folia end - region threading
         Set<io.papermc.paper.entity.TeleportFlag.Relative> relativeArguments;
         Set<io.papermc.paper.entity.TeleportFlag> allFlags;
         if (flags.length == 0) {
@@ -2067,7 +2072,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     private void unregisterEntity(Entity other) {
         // Paper end
         ChunkMap tracker = ((ServerLevel) this.getHandle().level()).getChunkSource().chunkMap;
-        ChunkMap.TrackedEntity entry = tracker.entityMap.get(other.getId());
+        ChunkMap.TrackedEntity entry = other.moonrise$getTrackedEntity(); // Folia - region threading
         if (entry != null) {
             entry.removePlayer(this.getHandle());
         }
@@ -2164,7 +2169,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
             if (original != null) otherPlayer.setUUID(original); // Paper - uuid override
         }
 
-        ChunkMap.TrackedEntity entry = tracker.entityMap.get(other.getId());
+        ChunkMap.TrackedEntity entry = other.moonrise$getTrackedEntity(); // Folia - region threading
         if (entry != null && !entry.seenBy.contains(this.getHandle().connection)) {
             entry.updatePlayer(this.getHandle());
         }
@@ -3345,7 +3350,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         {
             if ( CraftPlayer.this.getHealth() <= 0 && CraftPlayer.this.isOnline() )
             {
-                CraftPlayer.this.server.getServer().getPlayerList().respawn( CraftPlayer.this.getHandle(), false, Entity.RemovalReason.KILLED, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason.PLUGIN );
+                CraftPlayer.this.getHandle().respawn(null, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason.PLUGIN); // Folia - region threading
             }
         }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index e37aaf77f94b97b736cc20ef070cefdff0400188..ebbe224d81f6a96f3b05e3379cd0c5b5ab50fcbd 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -951,7 +951,7 @@ public class CraftEventFactory {
         return CraftEventFactory.handleBlockSpreadEvent(world, source, target, block, 2);
     }
 
-    public static BlockPos sourceBlockOverride = null; // SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep.
+    public static final ThreadLocal<BlockPos> sourceBlockOverrideRT = new ThreadLocal<>(); // SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep. // Folia - region threading
 
     public static boolean handleBlockSpreadEvent(LevelAccessor world, BlockPos source, BlockPos target, net.minecraft.world.level.block.state.BlockState block, int flag) {
         // Suppress during worldgen
@@ -963,7 +963,7 @@ public class CraftEventFactory {
         CraftBlockState state = CraftBlockStates.getBlockState(world, target, flag);
         state.setData(block);
 
-        BlockSpreadEvent event = new BlockSpreadEvent(state.getBlock(), CraftBlock.at(world, CraftEventFactory.sourceBlockOverride != null ? CraftEventFactory.sourceBlockOverride : source), state);
+        BlockSpreadEvent event = new BlockSpreadEvent(state.getBlock(), CraftBlock.at(world, CraftEventFactory.sourceBlockOverrideRT.get() != null ? CraftEventFactory.sourceBlockOverrideRT.get() : source), state); // Folia - region threading
         Bukkit.getPluginManager().callEvent(event);
 
         if (!event.isCancelled()) {
@@ -2229,7 +2229,7 @@ public class CraftEventFactory {
         CraftItemStack craftItem = CraftItemStack.asCraftMirror(itemStack.copyWithCount(1));
 
         org.bukkit.event.block.BlockDispenseEvent event = new org.bukkit.event.block.BlockDispenseEvent(bukkitBlock, craftItem.clone(), CraftVector.toBukkit(to));
-        if (!net.minecraft.world.level.block.DispenserBlock.eventFired) {
+        if (!net.minecraft.world.level.block.DispenserBlock.eventFired.get().booleanValue()) { // Folia - region threading
             if (!event.callEvent()) {
                 return itemStack;
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index 1354ccfbf525e5e64483ac5f443cc2325ba63850..fad85bea8643a3a88ec5c4194de7a5060e81c136 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -514,6 +514,7 @@ public class CraftScheduler implements BukkitScheduler {
     }
 
     protected CraftTask handle(final CraftTask task, final long delay) { // Paper
+        if (true) throw new UnsupportedOperationException(); // Folia - region threading
         // Paper start
         if (!this.isAsyncScheduler && !task.isSync()) {
             this.asyncScheduler.handle(task, delay);
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 32750451421fc559e9be1d98e6e328ede0049263..53817969cce8eed9e821c38a8b932f14dbb7ba8b 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -384,6 +384,12 @@ public final class CraftMagicNumbers implements UnsafeValues {
             throw new InvalidPluginException("Unsupported API version " + pdf.getAPIVersion());
         }
 
+        // Folia start - block plugins not marked as supported
+        if (!pdf.isFoliaSupported()) {
+            throw new InvalidPluginException("Plugin " + pdf.getFullName() + " is not marked as supporting regionised multithreading");
+        }
+        // Folia end - block plugins not marked as supported
+
         if (toCheck.isOlderThan(minimumVersion)) {
             // Older than supported
             throw new InvalidPluginException("Plugin API version " + pdf.getAPIVersion() + " is lower than the minimum allowed version. Please update or replace it.");
diff --git a/src/main/java/org/bukkit/craftbukkit/util/DelegatedGeneratorAccess.java b/src/main/java/org/bukkit/craftbukkit/util/DelegatedGeneratorAccess.java
index 09e87552159e24603aa9a4f658ab4449d7eaeb0a..698c8b061649fa84761f278ff7a2e9c88bb5fb87 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/DelegatedGeneratorAccess.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/DelegatedGeneratorAccess.java
@@ -66,6 +66,13 @@ public abstract class DelegatedGeneratorAccess implements WorldGenLevel {
         this.handle = worldAccess;
     }
 
+    // Folia start - region threading
+    @Override
+    public net.minecraft.world.level.StructureManager structureManager() {
+        return this.handle.structureManager();
+    }
+    // Folia end - region threading
+
     public WorldGenLevel getHandle() {
         return this.handle;
     }
diff --git a/src/main/java/org/spigotmc/SpigotCommand.java b/src/main/java/org/spigotmc/SpigotCommand.java
index 1b60abf5f5951288f6d54f522621472673eada6e..4ea06cb7a9e9db0d7feb0981de90015320c092d4 100644
--- a/src/main/java/org/spigotmc/SpigotCommand.java
+++ b/src/main/java/org/spigotmc/SpigotCommand.java
@@ -35,6 +35,7 @@ public class SpigotCommand extends Command {
                 .build()
             );
 
+            io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(() -> { // Folia - region threading
             MinecraftServer console = MinecraftServer.getServer();
             org.spigotmc.SpigotConfig.init((File) console.options.valueOf("spigot-settings"));
             for (ServerLevel world : console.getAllLevels()) {
@@ -43,6 +44,7 @@ public class SpigotCommand extends Command {
             console.server.reloadCount++;
 
             Command.broadcastCommandMessage(sender, text("Reload complete.", NamedTextColor.GREEN));
+            }); // Folia - region threading
         }
 
         return true;
diff --git a/src/main/java/org/spigotmc/SpigotConfig.java b/src/main/java/org/spigotmc/SpigotConfig.java
index e0d4222a99f22d7130d95cf29b034a98f2f3b76e..48432a7c9df33bae8aa72991843ed61545c64814 100644
--- a/src/main/java/org/spigotmc/SpigotConfig.java
+++ b/src/main/java/org/spigotmc/SpigotConfig.java
@@ -182,7 +182,7 @@ public class SpigotConfig {
         SpigotConfig.restartOnCrash = SpigotConfig.getBoolean("settings.restart-on-crash", SpigotConfig.restartOnCrash);
         SpigotConfig.restartScript = SpigotConfig.getString("settings.restart-script", SpigotConfig.restartScript);
         SpigotConfig.restartMessage = SpigotConfig.transform(SpigotConfig.getString("messages.restart", "Server is restarting"));
-        SpigotConfig.commands.put("restart", new RestartCommand("restart"));
+        //SpigotConfig.commands.put("restart", new RestartCommand("restart")); // Folia - region threading
     }
 
     public static boolean bungee;
@@ -228,7 +228,7 @@ public class SpigotConfig {
     }
 
     private static void tpsCommand() {
-        SpigotConfig.commands.put("tps", new TicksPerSecondCommand("tps"));
+        //SpigotConfig.commands.put("tps", new TicksPerSecondCommand("tps")); // Folia - region threading
     }
 
     public static int playerSample;
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index 89e2adbc1e1a0709d03e151e3ffcdbff10a44098..3476d639141c15ddb96fe0da1f11569e1e4b5bec 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -401,7 +401,7 @@ public class SpigotWorldConfig {
         this.otherMultiplier = (float) this.getDouble("hunger.other-multiplier", 0.0);
     }
 
-    public int currentPrimedTnt = 0;
+    //public int currentPrimedTnt = 0; // Folia - region threading - moved to regionised world data
     public int maxTntTicksPerTick;
     private void maxTntPerTick() {
         if (SpigotConfig.version < 7) {
